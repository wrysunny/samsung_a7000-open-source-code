package com.sec.android.app.dns.radioepg;import android.app.PendingIntent;import android.app.PendingIntent.CanceledException;import android.content.Context;import android.content.Intent;import android.media.MediaPlayer;import android.os.Handler;import java.util.Calendar;import java.util.Date;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import com.sec.android.app.dns.DNSEvent;import com.sec.android.app.dns.DNSService;import com.sec.android.app.dns.LogDns;import com.sec.android.app.dns.RadioDNSUtil;import com.sec.android.app.dns.radioepg.EpgPlayer.OnBufferingUpdateListener;import com.sec.android.app.dns.radioepg.EpgPlayer.OnInfoListener;import com.sec.android.app.dns.ui.DnsAlertDialogActivity;import com.sec.android.app.dns.ui.DnsAlertDialogActivity.DnsDialogFragment;import com.sec.android.app.fm.FMRadioFeature;import com.sec.android.app.fm.MainActivity;import com.sec.android.app.fm.R;import com.sec.android.app.fm.RadioPlayer;import com.sec.android.app.fm.SettingsActivity;import com.sec.android.app.fm.util.NetworkMonitorUtil;import com.sec.android.app.SecProductFeature_FMRADIO;public class EpgManager {    private static final int DELAY_SETTING_ISSTREAM = MainActivity.DELAY_WAITING_STREAM_STOPPED + 150;    private static final int POLLING_COUNT = 7;    private static final int POLLING_DELAY_NORMAL = 4000;    private static final int POLLING_DELAY_TO_RADIO = 500;    private static final int POLLING_DELAY_TO_STREAM = 300;    private static EpgManager sInstance = null;    private static final String TAG = "EPGManager";    public synchronized static EpgManager getInstance(Context context) {        if (context != null) {            if (sInstance == null || !sInstance.mContext.equals(context)) {                sInstance = new EpgManager(context);            }        }        return sInstance;    }    private boolean mAutoSwitching = false;    private long mBufferingTime = 0;    private final OnBufferingUpdateListener mBufferingUpdateListener = new OnBufferingUpdateListener() {        public void onBufferingUpdate(final EpgPlayer mp, final int percent) {            LogDns.d(TAG, "onBufferingUpdate() - " + percent + " %");        }    };    private Context mContext = null;    private EpgPlayer mEpgPlayer;    private EpgManagerHelper mHelper = null;    private EpgManagerHelper.OnPreparedListener mHelperListener = new EpgManagerHelper.OnPreparedListener() {        @Override        public void onPiPrepared(EpgData data) {            if (data == null) {                LogDns.e(TAG, "onPIPrepared() - data is null.");                return;            }            boolean res = data.getPiData() != null ? true : false;            String freq = data.getFrequency();            String pid = data.getProgramId();            String date = RadioDNSUtil.dateToString(data.getDate());            LogDns.d(TAG, "onPIPrepared() - valid:" + res + " pid:" + LogDns.filter(pid) + " freq:"                    + LogDns.filter(freq) + " date:" + date);            if (res) {                Intent intent = new Intent(DNSEvent.DNS_ACTION_UPDATE_NOW_EPG_DATA);                mContext.sendBroadcast(intent);                Intent intentForView = new Intent(DNSEvent.DNS_ACTION_PI_DATA_IS_UPDATED);                intentForView.putExtra("frequency", freq);                mContext.sendBroadcast(intentForView);            }        }        @Override        public void onXsiPrepared(EpgData data) {            if (data == null) {                LogDns.e(TAG, "onXSIPrepared() - data is null.");                return;            }            boolean res = data.getXsiService() != null ? true : false;            String freq = data.getFrequency();            LogDns.d(TAG, "onXSIPrepared() - valid:" + res + " freq:" + LogDns.filter(freq));            if (res) {                Intent intent = new Intent(DNSEvent.DNS_ACTION_UPDATE_NOW_EPG_DATA);                mContext.sendBroadcast(intent);            }            if (mPendingPollingRssi && freq.equals(mPendingPollingFrequency)) {                mPendingPollingRssi = false;                mPendingPollingFrequency = null;                mPollingRssiThread = new Thread(mPollingRssiRunnable);                mPollingRssiThread.start();            }        }    };    private final OnInfoListener mInfoListener = new OnInfoListener() {        public boolean onInfo(final EpgPlayer mp, final int what, final int extra) {            LogDns.d(TAG, "MediaPlayer mInfoListener. info = " + what);            Intent intent = null;            switch (what) {            case MediaPlayer.MEDIA_INFO_UNSUPPORTED_AUDIO:                LogDns.d(TAG, "MediaPlayer.MEDIA_INFO_UNSUPPORTED_AUDIO");                break;            case MediaPlayer.MEDIA_INFO_BUFFERING_START:                LogDns.d(TAG, "MediaPlayer MEDIA_INFO_BUFFERING_START");                intent = new Intent(mContext, DnsAlertDialogActivity.class);                intent.putExtra(DnsDialogFragment.KEY_MSG, R.string.dialog_popup_wait);                PendingIntent p = PendingIntent.getActivity(mContext, 0, intent,                        PendingIntent.FLAG_UPDATE_CURRENT);                try {                    p.send();                } catch (CanceledException e) {                    LogDns.e(TAG, e);                }                break;            case MediaPlayer.MEDIA_INFO_BUFFERING_END:                LogDns.d(TAG, "MediaPlayer.MEDIA_INFO_BUFFERING_END");                intent = new Intent(DNSEvent.DNS_ACTION_MEDIA_INFO_BUFFERING_END);                mContext.sendBroadcast(intent);                break;            case MediaPlayer.MEDIA_ERROR_IO:                LogDns.e(TAG, "MediaPlayer.MEDIA_ERROR_IO");                if (!mIsStreamPaused) {                    stopStreamRadio();                    setAutoSwitching(mAutoSwitching);                }                Handler handler = DNSService.getEventHandler();                if (handler != null) {                    handler.sendEmptyMessage(MediaPlayer.MEDIA_ERROR_IO);                }                break;            default:                break;            }            return false;        }    };    private boolean mIsPollingRssi = false;    private boolean mIsStreamPaused = false;    private boolean mIsStreamPlaying = false;    private String mPendingPollingFrequency = null;    private boolean mPendingPollingRssi = false;    private int mPollingCount = POLLING_COUNT;    private int mPollingDelayNormal = POLLING_DELAY_NORMAL;    private int mPollingDelayToRadio = POLLING_DELAY_TO_RADIO;    private int mPollingDelayToStream = POLLING_DELAY_TO_STREAM;    private Runnable mPollingRssiRunnable = new Runnable() {        public void run() {            LogDns.d(TAG, "mPollingRssiRunnable is running.");            boolean isReady = true;            if (!NetworkMonitorUtil.isConnected(mContext)) {                LogDns.d(TAG, "Network is unavailable.");                isReady = false;            }            if (!mAutoSwitching) {                LogDns.d(TAG, "Setting value is off");                isReady = false;            }            if (mIsStreamPlaying) {                LogDns.d(TAG, "Stream is already playing.");                isReady = false;            }            if (!isReady) {                mIsPollingRssi = false;                mPollingRssiThread = null;                return;            }            mIsPollingRssi = true;            try {                String freq = String.format("%05d", mRadioPlayer.getFrequency());                EpgData epgData = mHelper.getEpgData(freq);                Intent intent = new Intent(DNSEvent.DNS_ACTION_UPDATE_NOW_EPG_DATA);                mContext.sendBroadcast(intent);                if (epgData != null && epgData.getStreamUrl() != null) {                    long currentRSSI = 0;                    while (mIsPollingRssi && !mIsStreamPlaying) {                        Thread.sleep(mPollingDelayNormal);                        if (!mIsPollingRssi || mIsStreamPlaying)                            break;                        currentRSSI = mRadioPlayer.getCurrentRssi();                        /** for DSNTestActivity */                        intent = new Intent(DNSEvent.DNS_ACTION_UPDATE_RSSI);                        intent.putExtra(DNSEvent.DNS_EXTRA_RSSI, (int) currentRSSI);                        mContext.sendBroadcast(intent);                        LogDns.d(TAG, "Polling1 current RSSI : " + currentRSSI);                        if (currentRSSI < mRssiToChangeStream) {                            int count = 0;                            for (int i = 0; i < mPollingCount; i++) {                                Thread.sleep(mPollingDelayToStream);                                if (mIsStreamPlaying)                                    break;                                currentRSSI = mRadioPlayer.getCurrentRssi();                                LogDns.d(TAG, "Polling2 current RSSI : " + currentRSSI);                                if (currentRSSI < mRssiToChangeStream) {                                    count++;                                }                                if (count >= mPollingCount) {                                    intent = new Intent(mContext, DnsAlertDialogActivity.class);                                    intent.putExtra(DnsDialogFragment.KEY_MSG,                                            R.string.switch_to_internet_radio);                                    PendingIntent p = PendingIntent.getActivity(mContext, 0,                                            intent, PendingIntent.FLAG_UPDATE_CURRENT);                                    try {                                        p.send();                                    } catch (CanceledException e) {                                        LogDns.e(TAG, e);                                    }                                    mIsPollingRssi = false;                                }                            }                        }                    }                } else {                    LogDns.d(TAG, "mPollingRssiRunnable stopped because stream url is null.");                    mPendingPollingRssi = true;                    mPendingPollingFrequency = freq;                }            } catch (InterruptedException e) {                LogDns.d(TAG, e.getMessage());            } finally {                mIsPollingRssi = false;                mPollingRssiThread = null;                LogDns.d(TAG, "mPollingRssiRunnable finish");            }        }    };    private Thread mPollingRssiThread = null;    private RadioPlayer mRadioPlayer = null;    private int mRssiToChangeRadio = 0;    private int mRssiToChangeStream = 0;    private CountDownLatch mStartingStreamRadioGate = null;    private Thread mStreamThread = null;    private String mStreamUrl = null;    private EpgManager(Context context) {        mContext = context;        mIsStreamPlaying = false;        mHelper = new EpgManagerHelper();        mHelper.setOnPreparedListener(mHelperListener);        mRadioPlayer = RadioPlayer.getInstance();        if (SecProductFeature_FMRADIO.SEC_PRODUCT_FEATURE_FMRADIO_CONFIG_CHIP_VENDOR                .equals(FMRadioFeature.CHIP_SILICON)) {            mRssiToChangeStream = 18;            mRssiToChangeRadio = 22;        }/*          * else if          * (SecProductFeature_FMRADIO.SEC_PRODUCT_FEATURE_FMRADIO_SUPPORT_STE)          * {          * mRssiToChangeStream = 500;          * mRssiToChangeRadio = 800;          * } else if          * (SecProductFeature_FMRADIO.SEC_PRODUCT_FEATURE_FMRADIO_SUPPORT_CSR)          * {          * mRssiToChangeStream = -90;          * mRssiToChangeRadio = -60;          * }          */else if (SecProductFeature_FMRADIO.SEC_PRODUCT_FEATURE_FMRADIO_CONFIG_CHIP_VENDOR                .equals(FMRadioFeature.CHIP_QCOM)) {            mRssiToChangeStream = -105;            mRssiToChangeRadio = -98;        } else if (SecProductFeature_FMRADIO.SEC_PRODUCT_FEATURE_FMRADIO_CONFIG_CHIP_VENDOR                .equals(FMRadioFeature.CHIP_BRAODCOM)) {            mRssiToChangeStream = -101;            mRssiToChangeRadio = -96;        } else if (SecProductFeature_FMRADIO.SEC_PRODUCT_FEATURE_FMRADIO_CONFIG_CHIP_VENDOR                .equals(FMRadioFeature.CHIP_SPRD)) {            mRssiToChangeStream = -101;            mRssiToChangeRadio = -96;        }        mAutoSwitching = mContext.getSharedPreferences(SettingsActivity.PREF_FILE,        Context.MODE_PRIVATE).getBoolean(SettingsActivity.KEY_AUTO_SWITCH_TO_INTERNET,        false);    }    public long getBufferingTime() {        return mBufferingTime;    }    public EpgData getNowEpgData() {        return mHelper.getEpgData(String.format("%05d", mRadioPlayer.getFrequency()));    }    public PiData getPiData(String freq) {        EpgData data = mHelper.getEpgData(freq);        return data != null ? data.getPiData() : null;    }    public int getPollingCount() {        return mPollingCount;    }    public int getPollingDelayNormal() {        return mPollingDelayNormal;    }    public int getPollingDelayToRadio() {        return mPollingDelayToRadio;    }    public int getPollingDelayToStream() {        return mPollingDelayToStream;    }    public int getRssiToRadio() {        return mRssiToChangeRadio;    }    public int getRssiToStream() {        return mRssiToChangeStream;    }    public boolean isStreamAvailable(String freq) {        return mHelper.isStreamAvailable(freq);    }    public boolean isStreamPlaying() {        return mIsStreamPlaying;    }    public void pauseEpg() {        pauseStreamRadio();        stopPollingRssi();    }    public void pauseRecord() {        mEpgPlayer.pauseRecord();    }    private void pauseStream() {        if (mEpgPlayer != null && !mIsStreamPaused) {            mIsStreamPaused = true;            mEpgPlayer.stop();            LogDns.d(TAG, "Stream paused.");        }    }    public void pauseStreamRadio() {        LogDns.d(TAG, "pause InternetRadio");        pauseStream();    }    public void releaseRecord() {        mEpgPlayer.releaseRecord();    }    public void removeOnBufferingUpdateListener(OnBufferingUpdateListener listener) {        if (mEpgPlayer != null) {            mEpgPlayer.removeOnBufferingUpdateListener(listener);        }    }    public void resumeEpg() {        resumeStreamRadio();        mPollingRssiThread = new Thread(mPollingRssiRunnable);        mPollingRssiThread.start();    }    private void resumeStream() {        try {            if (mEpgPlayer != null && mIsStreamPaused) {                mEpgPlayer.play();                mIsStreamPaused = false;                Intent intent = new Intent(mContext, DnsAlertDialogActivity.class);                intent.putExtra(DnsDialogFragment.KEY_MSG, R.string.dialog_popup_wait);                PendingIntent p = PendingIntent.getActivity(mContext, 0, intent,                        PendingIntent.FLAG_UPDATE_CURRENT);                try {                    p.send();                } catch (CanceledException e) {                    LogDns.e(TAG, e);                }                LogDns.d(TAG, "Stream resumed");            }        } catch (IllegalStateException e) {            LogDns.e(TAG, e);            stopStreamRadio();        }    }    public void resumeStreamRadio() {        LogDns.d(TAG, "Resume InternetRadio");        resumeStream();    }    public void setAutoSwitching(boolean value) {        LogDns.d(TAG, "setAutoSwitching() - before:" + mAutoSwitching + " after:" + value);        mAutoSwitching = value;        if (mAutoSwitching) {            if (!mIsPollingRssi) {                mPollingRssiThread = new Thread(mPollingRssiRunnable);                mPollingRssiThread.start();            }        } else {            stopPollingRssi();        }    }    public void setDataTarget(String path) {        mEpgPlayer.setDataTarget(path);    }    public void setOnBufferingUpdateListener(OnBufferingUpdateListener listener) {        if (mEpgPlayer != null) {            mEpgPlayer.setOnBufferingUpdateListener(listener);        }    }    public void setOnRecordInfoListener(            com.sec.android.secmediarecorder.SecMediaRecorder.OnInfoListener listener) {        mEpgPlayer.setOnRecordInfoListener(listener);    }    public void setPollingCount(int pollingCount) {        this.mPollingCount = pollingCount;    }    public void setPollingDelayNormal(int pollingDelayNormal) {        this.mPollingDelayNormal = pollingDelayNormal;    }    public void setPollingDelayToRadio(int pollingDelayToFMRadio) {        this.mPollingDelayToRadio = pollingDelayToFMRadio;    }    public void setPollingDelayToStream(int pollingDelayToStream) {        this.mPollingDelayToStream = pollingDelayToStream;    }    public void setRssiToRadio(int rssi) {        mRssiToChangeRadio = rssi;    }    public void setRssiToStream(int rssi) {        mRssiToChangeStream = rssi;    }    private void setStreamRadio(boolean streamRadio) {        LogDns.d(TAG, "setStreamRadio() - " + streamRadio);        if (mIsStreamPlaying == streamRadio) {            LogDns.d(TAG, "setStreamRadio() - skipped");            return;        }        mIsStreamPlaying = streamRadio;        if (streamRadio) {            mRadioPlayer.setInternetStreamingMode(true);        } else {            /**             * Because of noise when stream is stop. Delayed setting mode is             * needed to block fm radio sound. Sequence : media player off - fm             * radio off - internet stream mode off             */            Handler handler = DNSService.getEventHandler();            if (handler != null) {                handler.sendEmptyMessageDelayed(DNSEvent.DNS_EPG_SET_ISSTREAM,                        DELAY_SETTING_ISSTREAM);            }        }        Intent intent = new Intent(DNSEvent.DNS_ACTION_UPDATE_ISSTREAM);        mContext.sendBroadcast(intent);    }    public void startPollingRssi() {        LogDns.v(TAG, "startPollingRssi()");        if (mIsPollingRssi) {            stopPollingRssi();        }        mPollingRssiThread = new Thread(mPollingRssiRunnable);        mPollingRssiThread.start();    }    public void startRecord() {        mEpgPlayer.record();    }    private void startStream() {        if (mStreamUrl == null)            return;        try {            if (mEpgPlayer == null)                mEpgPlayer = new EpgPlayer();            mEpgPlayer.initialize();            mEpgPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);            mEpgPlayer.setOnInfoListener(mInfoListener);            mEpgPlayer.setDataSource(mStreamUrl);            mEpgPlayer.play();            mBufferingTime = Calendar.getInstance().getTimeInMillis();        } catch (IllegalArgumentException e) {            LogDns.e(TAG, e);            setStreamRadio(false);        } catch (SecurityException e) {            LogDns.e(TAG, e);            setStreamRadio(false);        } catch (IllegalStateException e) {            LogDns.e(TAG, e);            setStreamRadio(false);        }    }    private void startStreamRadio() {        LogDns.d(TAG, "startStreamRadio()");        if (mIsPollingRssi) {            stopPollingRssi();        }        if (mIsStreamPlaying) {            System.out.println("Previous stream will be stopped.");            stopStreamRadio();        }        mStreamThread = new Thread() {            public void run() {                setStreamRadio(true);                startStream();                if (mStartingStreamRadioGate != null) {                    mStartingStreamRadioGate.countDown();                }            }        };        mStreamThread.start();    }    public void startStreamRadio(String freq) {        if (!NetworkMonitorUtil.isConnected(mContext)) {            LogDns.e(TAG, "startStreamRadio() - Network is unavailable.");            return;        }        EpgData epgData = mHelper.getEpgData(freq);        mStreamUrl = epgData != null ? epgData.getStreamUrl() : null;        LogDns.d(                TAG,                "startStreamRadio() - freq:" + LogDns.filter(freq) + " url:"                        + LogDns.filter(mStreamUrl));        if (mStreamUrl != null) {            startStreamRadio();        }    }    public void stopEpg() {        LogDns.d(TAG, "stopEpg()");        stopStreamRadio();        stopPollingRssi();    }    public void stopPollingRssi() {        LogDns.d(TAG, "stopCheckRSSI");        mIsPollingRssi = false;        if (mPollingRssiThread != null && mPollingRssiThread.isAlive())            mPollingRssiThread.interrupt();    }    public void stopRecord() {        mEpgPlayer.stopRecord();    }    private synchronized void stopStream() {        if (mEpgPlayer != null) {            mEpgPlayer.stop();            mEpgPlayer = null;        }        mIsStreamPaused = false;        mContext.sendBroadcast(new Intent(DNSEvent.DNS_ACTION_MEDIA_STOPPED));    }    public void stopStreamRadio() {        LogDns.d(TAG, "[EPGManager] stop InternetRadio");        if (DnsAlertDialogActivity.getInstance() != null)            DnsAlertDialogActivity.getInstance().finish();        stopStream();        setStreamRadio(false);    }    public void update(String freq, String pid, String countryCode, String url) {        mHelper.update(freq, pid, countryCode, url);    }    public boolean updatePi(String freq) {        return mHelper.updatePi(freq);    }    public boolean updatePi(String freq, String pid, Date date) {        return mHelper.updatePi(freq, pid, date);    }    public boolean waitAndGetStartingStreamRadio() {        mStartingStreamRadioGate = new CountDownLatch(1);        try {            LogDns.v(TAG, "waitStartingStreamRadio() - wait");            mStartingStreamRadioGate.await(100, TimeUnit.MICROSECONDS);        } catch (InterruptedException e) {            LogDns.e(TAG, e);        } finally {            LogDns.v(TAG, "waitStartingStreamRadio() - end");            mStartingStreamRadioGate = null;        }        return mIsStreamPlaying;    }}