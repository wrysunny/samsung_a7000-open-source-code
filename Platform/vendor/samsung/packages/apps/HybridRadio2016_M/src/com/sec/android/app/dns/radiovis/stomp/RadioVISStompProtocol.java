package com.sec.android.app.dns.radiovis.stomp;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStream;import java.net.Socket;import java.net.UnknownHostException;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import com.sec.android.app.dns.DNSService;import com.sec.android.app.dns.LogDns;import com.sec.android.app.dns.data.RadioDNSData;import com.sec.android.app.dns.data.SrvRecord;import com.sec.android.app.dns.radiovis.RadioVISProtocol;public class RadioVISStompProtocol implements RadioVISProtocol {    /**     * ReceiverThread should be unique because RadioVISStompProtocol &     * RadioVISFrame are singleton. ReceiverThread shares     * RadioVISStompProtocol's member variables(mSocket, mReader and mWriter).     */    private class ReceiverThread extends Thread {        private boolean mIsRunning = false;        public ReceiverThread() {            super("ReceiverThread");            setDaemon(true);        }        public void finish() {            LogDns.v(TAG, "finish()");            mIsRunning = false;        }        public void recover() {            LogDns.v(TAG, "recover()");            mIsRunning = true;        }        @Override        public void run() {            LogDns.v(TAG, "ReceiverThread start");            RadioDNSData dnsData = mDnsService.getCurrentData();            String exceptionMsg = null;            try {                if (dnsData != null) {                    mHost = dnsData.getVisStompHost();                    mPort = dnsData.getVisStompPort();                    LogDns.v(TAG, LogDns.filter(dnsData.toString()));                } else {                    LogDns.e(TAG, "Dns data is null");                    return;                }                if (SrvRecord.EMPTY_NUMBER == mPort)                    return;                mSocket = new Socket(mHost, mPort);                if (!mIsRunning)                    return;                mReader = new BufferedReader(new InputStreamReader(mSocket.getInputStream(),                        CHARSET_UTF_8));                mWriter = mSocket.getOutputStream();                transmitData(CONNECT, null);                StringBuffer stompFrame = new StringBuffer();                while (mIsRunning) {                    if (mReader.ready()) {                        int character = 0;                        stompFrame.setLength(0);                        while (mIsRunning) {                            if ((character = mReader.read()) <= 0)                                break;                            stompFrame.append((char) character);                        }                        LogDns.v(TAG, "Receive frame - " + LogDns.filter(stompFrame.toString()));                        if (mIsRunning) {                            if (stompFrame.toString().trim().equals("")) {                                LogDns.e(TAG, "Received Frame is empty. thread will finish.");                                break;                            } else {                                if (mListener != null)                                    mListener.onCallbackReceived(stompFrame.toString());                            }                        }                    }                    sleep(RECEIVER_TIME_INTERVAL);                }            } catch (UnknownHostException e) {                exceptionMsg = e.getMessage();                e.printStackTrace();            } catch (IOException e) {                exceptionMsg = e.getMessage();                e.printStackTrace();            } catch (InterruptedException e) {                LogDns.d(TAG, "ReceiverThread is interrupted");            } finally {                if (exceptionMsg != null && mListener != null)                    mListener.onCallbackReceived(exceptionMsg);                transmitData(UNSUBSCRIBE, null);                transmitData(DISCONNECT, null);                closeReader();                closeWriter();                closeSocket();                // It should be synchronized with connectNetwork();                if (mReceiverThread != null) {                    synchronized (mReceiverThread) {                        mReceiverThread = null;                    }                }                LogDns.v(TAG, "ReceiverThread finish");                if (mReceiverThreadFinishGate != null) {                    mReceiverThreadFinishGate.countDown();                }            }        }        @Override        public synchronized void start() {            mIsRunning = true;            super.start();        }    }    public static final int _CONNECTED = 0;    public static final int _ERROR = 2;    public static final int _MESSAGE = 1;    public static final String ACK = "ack";    public static final int BODY_SHOWSIZE = 512;    public static final int BODY_TEXTSIZE = 128;    public static final String CHARSET_US_ASCII = "US-ASCII";    public static final String CHARSET_UTF_8 = "UTF-8";    public static final String CONNECT = "CONNECT";    public static final String CONNECTED = "CONNECTED";    public static final String CONTENT_LENGTH = "content-length";    public static final String CONTENT_TYPE = "content-type";    public static final String DESTINATION = "destination";    public static final String DISCONNECT = "DISCONNECT";    public static final String ERROR = "ERROR";    public static final String EXPIRES = "expires";    public static final String LINK = "link";    public static final String MESSAGE = "MESSAGE";    public static final String MESSAGE_ID = "message-id";    public static final int NOUPDATE = 0;    private static final int RECEIVER_TIME_INTERVAL = 500;    public static final String SEND = "SEND";    public static final String SHOW = "SHOW";    private static RadioVISStompProtocol sInstance;    public static final String SUBSCRIBE = "SUBSCRIBE";    private static final String TAG = "RadioVISSTompProtocol";    public static final String TEXT = "TEXT";    public static final String TIMESTAMP = "timestamp";    public static final String TRIGGER_TIME = "trigger-time";    public static final String UNSUBSCRIBE = "UNSUBSCRIBE";    public static final int UPDATEALL = 3;    public static final int UPDATESHOWONLY = 2;    public static final int UPDATETEXTONLY = 1;    public synchronized static RadioVISStompProtocol getInstance() {        if (sInstance == null)            sInstance = new RadioVISStompProtocol();        return sInstance;    }    private DNSService mDnsService = null;    private String mHost;    private RadioVISStompClient.OnCallbackListener mListener = null;    private int mPort;    private BufferedReader mReader;    private ReceiverThread mReceiverThread = null;    private CountDownLatch mReceiverThreadFinishGate = null;    private Socket mSocket;    private OutputStream mWriter;    private RadioVISStompProtocol() {        mDnsService = DNSService.getInstance();    }    private void closeReader() {        if (mReader != null) {            try {                mReader.close();            } catch (IOException e) {                e.printStackTrace();            } finally {                mReader = null;            }        }    }    private void closeSocket() {        if (mSocket != null && !mSocket.isClosed()) {            try {                mSocket.close();            } catch (IOException e) {                e.printStackTrace();            } finally {                mSocket = null;            }        }    }    private void closeWriter() {        if (mWriter != null) {            try {                mWriter.close();            } catch (IOException e) {                e.printStackTrace();            } finally {                mWriter = null;            }        }    }    public void connectNetwork() {        LogDns.v(TAG, "connectNetwork()");        // Check mReceiverThread's state and reuse it.        if (mReceiverThread != null) {            synchronized (mReceiverThread) {                RadioDNSData dnsData = mDnsService.getCurrentData();                String host = dnsData.getVisStompHost();                int port = dnsData.getVisStompPort();                if (host != null && host.equals(mHost) && port == mPort) {                    mReceiverThread.recover();                    return;                }                mReceiverThreadFinishGate = new CountDownLatch(1);                mReceiverThread.finish();                mReceiverThread.interrupt();            }            /*             * Used mReceiverThread should be finished ASAP because this is             * running UI thread. And this should wait finishing             * mReceiverThread. Refer to ReceiverThread comments             */            try {                LogDns.d(TAG, "Waiting ReceiverThread finished");                mReceiverThreadFinishGate.await(RECEIVER_TIME_INTERVAL, TimeUnit.MICROSECONDS);                mReceiverThreadFinishGate = null;            } catch (InterruptedException e) {                e.printStackTrace();            }        }        mReceiverThread = new ReceiverThread();        mReceiverThread.start();    }    @Override    public void disconnectNetwork() {        LogDns.v(TAG, "disconnectNetwork()");        if (mReceiverThread != null)            mReceiverThread.finish();    }    private String getTopic(String topicType) {        RadioDNSData data = mDnsService.getCurrentData();        StringBuilder topicBuilder = new StringBuilder("/topic/fm");        topicBuilder.append("/" + data.getCountryCode() + "/" + data.getPi() + "/"                + data.getFrequency());        topicBuilder.append("/" + topicType);        return topicBuilder.toString();    }    public void setListener(RadioVISStompClient.OnCallbackListener listener) {        mListener = listener;    }    public void subscribe() {        transmitData(SUBSCRIBE, getTopic("image"));        transmitData(SUBSCRIBE, getTopic("text"));    }    private void transmitData(String stompCommand, String header) {        LogDns.v(TAG, "TransmitFrame - start");        StringBuilder stompFrame = new StringBuilder(stompCommand);        stompFrame.append("\n");        if (stompCommand.equals(SUBSCRIBE) && (header != null))            stompFrame.append(DESTINATION + ":" + header + "\n");        stompFrame.append("\n");        stompFrame.append("\000");        try {            LogDns.v(TAG, "Send frame - " + LogDns.filter(stompFrame.toString()));            if (mWriter == null)                LogDns.e(TAG, "writer is null");            else                mWriter.write(stompFrame.toString().getBytes(CHARSET_US_ASCII));        } catch (IOException e) {            e.printStackTrace();        }    }}